---
title: 'From Messy to Tidy: Separate the Category'
author: Recle Etino Vibal
date: '2018-10-12'
slug: messy-tidy-separate-category
categories:
  - lessons
  - Philippines
  - tidyverse
  - tidy data
tags:
  - consumer price index
  - dplyr
  - rebus
  - tidyr
output:
  blogdown::html_page:
    toc: yes
    number_sections: true
bibliography:
  - references/messy-to-tidy.bib
biblio-style: apalike
---

```{r packages-opts, message=FALSE, warning=FALSE, include=FALSE}

xfun::pkg_attach(
  "knitr",
  "tidyverse",
  "magrittr",
  "DT",
  "rebus",
  "janitor"
)

opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo = FALSE
)

```

# Dates in One Column

The [first post](https://amateurdatasci.rbind.io/post/messy-tidy-tidyr-gather/) in the From Messy to Tidy series introduced us to the idea of tidy data (@tidy-data):

>Data is tidy when 
>1. Every column is a variable, 
2. Every row is an observation, and 
3. Every observational unit forms a table.

Dates as column names is one sign of a **messy** data. My previous post focused on collecting the date columns into a single column and converting the dates to [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) (YYYY-MM-DD) format. 

Here is a sample view of the data^[For reference, the data I am tidying here is the Philippines consumer price index from 1994 Jan to 2018 Jun retrieved [here](http://openstat.psa.gov.ph/dataset/prices-and-related-indices) on 2018 Sep 28] so far. While reading the data into this post, I also cleaned the column names to replace the unnecesary spaces with underscores. I did this, and can do more column names cleaning with `janitor::clean_names()` (@R-janitor).

```{r read-show-sample, fig.cap="Sample Philippine Consumer Price Index Data with a Single ISO 8601 Date Column."}

# read the partially-cleaned data and clean the column names

iso_8601_cpi_data <- 
  readr::read_rds("./data/ph-cpi-data/partial-tidy/iso-8601-cpi-data.RDS") %>% 
  janitor::clean_names()

# show sample data

iso_8601_cpi_data %>% 
  head(40) %>% 
  DT::datatable(
    rownames = FALSE,
    options = list(
      autoWidth = TRUE,
      scrollX = TRUE,
      pageLength = 20,
      columnDefs = list(
        list(
          className = 'dt-center',
          targets = 0:(ncol(iso_8601_cpi_data) - 1)
        )
      )
    )
  )

```

# Deciphering the Code Column

One quick look at Figure \@ref(fig:read-show-sample) reminds us that the data is not yet tidy. For one, what does the `Code` column mean?

Some of the readers might have noticed it already, but it took me a while to realize that the `code` column is related to the `description` column. We can see this better if we isolate the `code` and `description` columns. I did this with `dplyr::distinct()` (@R-dplyr).

```{r code-description, fig.cap="The `code` and `description` Column Relationship."}

# isoalte code and description column

item_code_description <- 
  iso_8601_cpi_data %>% 
  distinct(code, description)

# display isolated code and description column

item_code_description %>% 
  DT::datatable(
    rownames = FALSE,
    options = list(
      pageLength = 20,
      columnDefs = list(
        list(
          className = 'dt-center',
          targets = 0:1
        )
      )
    )
  )

```

Upon reviewing Figure \@ref(code-description), I noticed that the `code` and `description` columns identify the same thing, on what item the consumer price index measures. For example, a 01 `code` refers to the Food and Non-Alcoholic Beverages category. If we notice that 01.1 refers to the Food category and 01.2 to the Non-Alcoholic Bevarages category, then we get the pattern. A # `code` refers to the top category, #.# to the item's subcategory, and #.#.# to the item's sub-subcategory.

The `description` can be thought of as variable because one observation of an item can only have one description. However, the `code` is a representation of at most three variables. I think this violates tidy data principles. Each level should have its own column, in my opinion. The `code` column is good for identification purposes, but this is not as useful to the data analyst. Imagine if we want to look at only the subcategories of Recreation and Culture. It will take us some time to understand the `code` column first before we can do what we want.


